# from typing import Optional
from google.adk.agents import LlmAgent
from google.adk.tools.function_tool import FunctionTool
from google.adk.tools.tool_context import ToolContext

from src.auto_nom_agent.configs import retry_options, model
from google.adk.models.google_llm import Gemini
from google.adk.agents.callback_context import CallbackContext

from src.utils.state import is_valid_transition


def update_user_choice(choice: list[int], tool_context: ToolContext) -> dict[str, str]:
    """
    Updates the state with the choice number that the user selected. 

    Args:
        choice (int): number representing the user selection

    Returns:
        dict[str,str]: response dictionary with update operation status and message
    """
    tool_context.state["user_choice"] = choice
    tool_context.state["workflow_status"] = "USER_APPROVAL_RECEIVED"

    return {
        "status": "success",
        "message": "User restaurant choice has been saved"
    }


def update_user_feedback(feedback: str, tool_context: ToolContext) -> dict[str, str]:
    """
    Updates the state with the feedback provided by the user. 

    Args:
        choice (int): number representing the user selection

    Returns:
        dict[str,str]: response dictionary with update operation status and message
    """
    tool_context.state["user_feedback"] = feedback
    tool_context.state["workflow_status"] = "USER_REJECTION_RECEIVED"

    return {
        "status": "success",
        "message": "User feedback has been saved"
    }


def update_meal_choice_verification_message(meal_choice_verification_message: str, choices:list[dict[str, str]], tool_context: ToolContext) -> dict[str, str]:
    """Updates the state with the meal choice verification message

    Args:
        meal_choice_verification_message (str): meal choice verification message that we send to the users

    Returns:
        dict[str, str]: response dictionary with update operation status and message
    """
    tool_context.state["meal_choice_verification_message"] = meal_choice_verification_message
    tool_context.state["meal_choices"] = choices

    return {
        "status": "success",
        "message": "Meal choice verification message has been saved"
    }


def on_before_meal_verifier_agent_call(callback_context: CallbackContext) -> None:
    current_state = callback_context.state["workflow_status"]
    new_state = "MEAL_PLANNING_COMPLETE"

    if is_valid_transition(current_state, new_state):
        callback_context.state["workflow_status"] = new_state

    return None


def on_after_meal_verifier_agent_call(callback_context: CallbackContext) -> None:
    current_state = callback_context.state["workflow_status"]
    new_state = "AWAITING_USER_APPROVAL"

    if is_valid_transition(current_state, new_state):
        callback_context.state["workflow_status"] = new_state

    return None


meal_choice_verifier = LlmAgent(
    model=Gemini(model=model, retry_options=retry_options),
    name="MealChoiceVerifier",
    description="Shares the meal options with the user and confirms their choice",
    instruction="""
    You are a helpful, polite, and cheerful assistant whose role is to share the researched meal options with the user and wait for their selection.

    **INPUT DATA:**
    Meal Options: {meal_options}

    **TASK EXECUTION:**
    1. **Analyze Options:** Review the provided meal options.
    2. **Format & Save:** You must format the output into two distinct parts and save them using the `update_meal_choice_verification_message` tool:
       - **`message`**: A friendly, short text greeting introducing the options (e.g., "I found some great spots for you!"). Do NOT list the options here.
       - **`choices`**: A structured JSON list of the options.

    **CHOICES SCHEMA:**
    Each item in the `choices` list must match this structure exactly:
    {
        "id": "String (The Menu Item ID, e.g., 'm_001_1')",
        "restaurant_name": "String",
        "menu_item_name": "String",
        "description": "String (A enticing description generated by you based on the data)",
        "price": Number (Float),
        "calories": Number (Integer)
        "special_instructions": "String (any special instructions for the menu item based on the data)"
    }

    3. **Wait for User:** After calling the tool, your job is effectively paused.
    4. **Handle Response:** When the user replies (after the pause):
       - If the user selected a number (1, 2, 3), use `update_user_choice(choice_index)`.
       - If the user rejected or gave feedback, use `update_user_feedback(feedback_text)`.
    
    **CRITICAL RULES:**
    - Do NOT simply print the options in markdown. You MUST use the tool to save the structured data.
    - Do NOT share internal IDs like 'r_001' in the `message` text.
    """,
    tools=[
        FunctionTool(update_user_choice),
        FunctionTool(update_meal_choice_verification_message),
        FunctionTool(update_user_feedback)],
    before_agent_callback=on_before_meal_verifier_agent_call,
    after_agent_callback=on_after_meal_verifier_agent_call

)
